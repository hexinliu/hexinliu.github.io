<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome</title>
    <link>https://hexinliu.github.io/</link>
    <description>Recent content on Welcome</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Jan 2020 20:01:25 +0800</lastBuildDate>
    
	<atom:link href="https://hexinliu.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[数据结构]链表  反转链表</title>
      <link>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 20 Jan 2020 20:01:25 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>[数据结构]链表&amp;ndash;反转链表  题目描述 反转一个单链表
示例： 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 算法1(循环)： 遍历链表，将当前结点的next指向当前结点的前一个结点，由于结点定义时没有定义前驱指针，故必须提前保存当前结点的前一个结点，在进行更改之前，还需保存当前结点的下一个结点。
题解： class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; ListNode current = head; ListNode next = null; while (current != null) { next = current.next; current.next = pre; pre = current; current = next; } return pre; } } 复杂度：  时间复杂度：假设链表长度为n，则为O(n) 空间复杂度：O(1)   算法2(递归)： 假设链表是[1, 2, 3, 4, 5]从最底层最后一个reverseList(5)来看
 返回了5这个节点 reverseList(4)中 p为5 head.</description>
    </item>
    
    <item>
      <title>[数据结构]链表  移除链表元素</title>
      <link>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 19 Jan 2020 22:16:14 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</guid>
      <description>[数据结构]链表&amp;ndash;移除链表元素  题目描述 删除链表中等于给定值val的所有值。
示例： 输入: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 算法(哨兵结点)： 初始化一个哨兵结点作为伪头，初始化两个指针分别指向当前结点和当前结点的前驱结点。比较当前结点的值和给定的值，若相等，让前驱结点的next指向当前结点的next；若不相等，让当前结点作为前驱结点。当前结点向后移动，继续判断。
题解： class Solution { public ListNode removeElements(ListNode head, int val) { ListNode sentinel = new ListNode(-1); sentinel.next = head; ListNode current = head; ListNode pre = sentinel; while (current != null ) { if (current.val == val) pre.next = current.next; else pre = current; current = current.next; } return sentinel.next; } }  这个题目如果要删除的结点是中间结点，会很简单；但如果删除的是位于链表头部的一个或多个结点，会很复杂。这里遇到一个重要的思想：哨兵结点
​	哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。</description>
    </item>
    
    <item>
      <title>[数据结构]链表  相交链表</title>
      <link>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 18 Jan 2020 14:11:46 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>[数据结构]链表&amp;ndash;相交链表  题目描述 编写一个程序，找到两个单链表相交的起始结点。（可假定两个链表中都没有环）
如下面的两个链表**：**

在节点 c1 开始相交。
示例1： 
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。``` 示例2： 
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Reference of the node with value = 2 输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例3：</description>
    </item>
    
    <item>
      <title>[数据结构]链表  环形链表</title>
      <link>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 17 Jan 2020 15:34:55 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>[数据结构]链表&amp;ndash;环形链表  题目描述 给定一个链表，判断链表中是否有环。
算法1（哈希表）： 遍历所有结点，然后在哈希表中存储每个结点的引用，当检测到空节点null时，说明已经检测到最后一个结点，并且该链表中没有环。若当前结点的引用已存在于哈希表中，说明有环。（检查一个结点此前是否被访问过）
题解： public class Solution { public boolean hasCycle(ListNode head) { Set&amp;lt;ListNode&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); while(head != null) { if (set.contains(head)) { return true; } else set.add(head); head = head.next; } return false; } } 复杂度：  时间复杂度：O(n)，对于含有n个元素的链表，每个元素最多访问一次，往哈希表中添加一个元素最多花费O(1)时间。 空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目。最多可以添加n个元素。  算法2（双指针）： 使用具有不同速度的快、慢两个指针，快指针每次走两步，慢指针每次走一步。考虑一个环形链表，把快慢指针想象成在环形跑道上跑步的运动员，快跑者一定能追上慢跑者。时间允许的情况下，他们一定会相遇。
题解： public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) return false; ListNode fast = head.</description>
    </item>
    
    <item>
      <title>[数据结构]链表  删除排序链表中的重复元素</title>
      <link>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 16 Jan 2020 22:56:24 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid>
      <description>[数据结构]链表&amp;ndash;删除排序链表中的重复元素  题目描述 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例1： 输入：1-&amp;gt;1-&amp;gt;2
输出：1-&amp;gt;2
示例2： 输入：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3
输出：1-&amp;gt;2-&amp;gt;3
算法： 1.从第一个元素开始，依次向后比较，若值相同，则直接指向下一个的下一个继续比较；若值不同，从该不同的值开始继续向后比较。
2.由于操作过程中如果使用头指针会导致头指针丢失，故用一个副本current代替head进行操作。
题解： class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode current = head; while (current != null &amp;amp;&amp;amp; current.next != null) { if (current.val == current.next.val) { current.next = current.next.next; } else { current = current.next; } } return head; } } </description>
    </item>
    
    <item>
      <title>[数据结构]链表  合并两个有序链表</title>
      <link>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 14 Jan 2020 22:49:29 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%93%BE%E8%A1%A8-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>[数据结构]链表&amp;ndash;合并两个有序链表  题目描述 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。
示例： 输入：1-&amp;gt;1-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
算法(递归解法)： 1.如果两个链表有一个是空链表，那么不需要合并，直接返回非空链表。
2.否则，比较l1和l2两个链表哪个的头元素更小，选择更小的添加到结果里，如果两个链表都为空，则过程终止。
题解： class ListNode{ int val; ListNode next; ListNode (int x) { val = x; } } public class mergeTwoLists { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val &amp;lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.</description>
    </item>
    
    <item>
      <title>Hugo常用命令</title>
      <link>https://hexinliu.github.io/post/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 13 Jan 2020 17:30:20 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>Hugo 安装配置文档地址： https://blog.51cto.com/michaelkang/2364007 本文环境介绍 #hugo 版本 version Hugo Static Site Generator v0.54.0 linux/amd64 BuildDate: 2019-02-22T08:11:04Z #go 版本 go version go1.11.5 linux/amd64 #系统版本 more /etc/redhat-release CentOS Linux release 7.6.1810 (Core) #版本和环境详细信息 hugo env Hugo Static Site Generator v0.54.0 linux/amd64 BuildDate: 2019-02-22T08:11:04Z GOOS=&amp;quot;linux&amp;quot; GOARCH=&amp;quot;amd64&amp;quot; GOVERSION=&amp;quot;go1.11.5&amp;quot; 初始化站点 始化一个站点目录 www.datals.com
hugo new site /www.datals.com 目录结构介绍： cd /www.datals.com/ ll ▸ archetypes/ #包括内容类型，在创建新内容时自动生成内容的配置 ▸ content/ # 网站内容，全部使用markdown格式 ▸ layouts/ # 网站模板文件，决定内容如何呈现 ▸ static/ # 图片、css、js 等静态资源 ▸ themes/ # 存放主题 config.</description>
    </item>
    
    <item>
      <title>windows&#43;hugo&#43;github搭建个人博客</title>
      <link>https://hexinliu.github.io/post/df/</link>
      <pubDate>Mon, 13 Jan 2020 15:24:13 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/df/</guid>
      <description>windows + hugo + github 1.安装hugo hugo下载
1.根据自己情况下载对应版本，下载完成之后解压待用
2.创建一个文件夹，如在E盘创建hugo/bin,将解压出来的hugo.exe文件放入bin中
3.配置系统环境变量，将E:\hugo\bin添加到path环境变量中（如果没有在环境变量中添加hugo可执行文件的路径的话，每一次都要写全hugo.exe的路径或者切换到hugo所在的目录，过于麻烦。而将该路径添加到环境变量中之后，可以在cmd中随便使用hugo命令了）
注意：往path中添加的路径只要到hugo.exe所在的文件夹即可，不需要包含hugo.exe。
 以上工作进行完之后，检查是否操作成功，打开cmd，输入hugo version
若出现：
Hugo Static Site Generator v0.62.1-A1518704 windows/amd64 BuildDate: 2020-01-01T17:39:35Z 则说明安装且配置成功
2.安装git 这个过程中需要用到git，关于git的安装和使用，网上有很多资料，这里不提
git下载地址
git下载和解压成功后，可以在解压后的文件夹中发现两个可执行文件，一个git-bash.exe和一个git-cmd.exe。(区别：bash是linux风格的命令行，路径也是linux式的，可以使用windows命令和linux命令；cmd是windows风格的命令行，可以使用windows命令)
3.生成hugo博客站点 打开一个git命令行，进入E:\hugo下，敲命令:
hugo new site 文件名称(如:myblog) 执行完这条命令之后，会在hugo目录下生成一个名为myblog的站点文件夹
进入这个文件夹后，显示以下目录结构：
 archetypes (存放default.md,头文件的格式，每次新建文章默认显示的头部信息在此修改) content (存放博客文章，Markdown格式的文件) data (存放自定义或者导入的模板) layouts (存放网站的数据模板) static (存放图片,js,css等静态资源) themes (存放主题文件，每一个主题都是一个独立的文件夹) config.toml （网站配置文件，如baseURL=“&amp;hellip;”作用是无论是在本地还是发布出去，图片的路径都是相对于baseURL而言的）  4.下载主题 hugo主题下载地址
选定一个主题，点击进入，找到安装部分，如
复制以上命令，即可将主题clone到本地的themes文件夹下（themes下的每一个文件夹都是一个主题）
5.在本地启动站点 hugo server -t 已下载的主题名称(如prologue) --buildDrafts 这时候便可以对图中的地址进行访问了但这时候站点是空的，什么都没有
6.写一篇博客 回到E:\hugo\myblog&amp;gt;,执行
hugo new post/myFirstBlog.md 这个命令的意思是在content目录下，创建一个post目录，再在post目录下创建了一个名为myFirstBlog的博客文件，以后写博客就用这个命令(或者用hugo new gg.</description>
    </item>
    
    <item>
      <title>Maven</title>
      <link>https://hexinliu.github.io/post/maven/</link>
      <pubDate>Sun, 12 Jan 2020 22:17:12 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/maven/</guid>
      <description>Maven  1.什么是Maven
​	Maven是一个项目管理工具，它包含一个项目对象模型(POM:Project Object Model),一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。
2.核心功能之依赖管理
3.核心功能之一键构建
​	*什么是构建：
​	构建是指项目从编译，测试，运行，打包，安装，部署整个过程都交给maven进行管理，这个过程称为构建。
​	*什么是一键构建
​	指的是整个构建过程中，使用maven一个命令可以轻松完成整个工作。
​	4.Maven的安装（下载Maven安装包并解压）
​	bin目录下的mvn：用于构建项目。
​	boot：Maven自身运行所需要的类加载器
​	conf中的settings.xml：对Maven进行配置时所使用的主要的配置文件
​	lib：Maven自身运行所需要的jar包
​
​	Maven的安装：
​	1.复制Maven解压后的目录，打开我的电脑，属性&amp;ndash;&amp;gt;高级系统设置&amp;ndash;&amp;gt;环境变量(系统变量中)，新建一个变量，变量名：MAVEN_HOME 变量值：所复制的目录。
​	2.进入Path环境变量，新建一个%MAVEN_HOME%\bin
​	3.Maven运行需要Java，必须确保环境变量中有JAVA_HOME。
​	4.检验安装是否成功：打开命令窗口，输入mvn -version或mvn -v，出现maven相关信息，即说明Maven安装成功。
5.修改仓库位置
​	进入Maven的config目录下的settings.xml，找到
​
&amp;lt;!--localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt; 将其中的‘/path/to/local/repo’标签中的内容替换为自定义仓库的位置
6.仓库的分类
7.Maven项目标准目录结构</description>
    </item>
    
    <item>
      <title>Tomcat</title>
      <link>https://hexinliu.github.io/post/blog/</link>
      <pubDate>Sun, 12 Jan 2020 16:03:41 +0800</pubDate>
      
      <guid>https://hexinliu.github.io/post/blog/</guid>
      <description>Tomcat配置：
​	*部署项目的方式：
​	1.直接将项目放到webapps目录下
​	*简化部署：将项目打成一个war包，再将war包放置到webapps目录下(war包会自动解压)
​	2.配置conf/server.xml文件
​	在标签体中配置
​	例子：	​	*docBase:项目存放的路径
​	*path:虚拟目录
​	3.在conf\Catalina\localhost创建任意名称的xml文件，在文件中编写
​	​	*虚拟目录：xml文件的名称
​	*静态项目和动态项目
​	*目录结构
​	java动态项目的目录结构：
​	&amp;ndash;项目的根目录:
​	&amp;ndash;WEB-INF目录:
​	&amp;ndash;web.xml：web项目的核心配置文件
​	&amp;ndash;classes目录：放置字节码文件的目录
​	&amp;ndash;lib目录：放置依赖的jar包
IDEA与Tomcat相关配置
​	1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件
​	查看控制台的log：Using CATALINA_BASE: &amp;ldquo;C:\Users\16422.IntelliJIdea2019.1\system\tomcat\Tomcat_8_5_47_JavaWeb_Tomcat&amp;rdquo;
​	2.工作空间项目 和 Tomcat部署的web项目
​	*Tomcat真正访问的是“Tomcat部署的web项目”，“Tomcat部署的web项目”对应着“工作空间项目”的web目录下的所有资源
​	*WEB-INF目录下的资源不能被浏览器直接访问
​	3.断点调试：使用“小虫子”启动debug</description>
    </item>
    
  </channel>
</rss>